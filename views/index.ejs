<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Image Processor</title>
    <link rel="stylesheet" href="/style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <h1>üñºÔ∏è Image Processor</h1>

    <form id="uploadForm" enctype="multipart/form-data">
        <div class="main-container">
            <div class="upload-section">
                <h2>Upload Image</h2>

                <div id="dropArea" class="drop-area">
                    <p id="dropText">üìÇ Drag & drop or click to upload</p>
                    <img id="previewImage" />
                    <input id="imageInput" type="file" name="image" accept="image/*" />
                </div>

                <button type="submit">Upload</button>

                <div id="progressContainer" style="display:none;">
                    <div id="progressBar"></div>
                </div>
            </div>

            <div class="output-section">
                <h2>Processed Output</h2>
                <p id="queueStatus">Queue: <span id="queueSize">0</span>, Status: <span id="processingStatus">Idle</span>, Your Position: <span id="yourPosition">N/A</span></p>
                <div class="image-box">
                    <p id="outputPlaceholder" class="placeholder">Your processed image will appear here.</p>
                    <img id="outputImage" src="" alt="Processed Image" style="display:none;" />
                </div>
                <a id="downloadLink" href="#" download style="display:none;">
                    <button class="download-btn" type="button">Download</button>
                </a>
            </div>
        </div>
    </form>

    <div class="settings-section">
        <h2>Settings</h2>
        <p>Future filters and options will go here.</p>
    </div>

    <script>
        const imageInput = document.getElementById('imageInput');
        const previewImage = document.getElementById('previewImage');
        const dropArea = document.getElementById('dropArea');
        const dropText = document.getElementById('dropText');
        const uploadForm = document.getElementById('uploadForm');
        const progressBar = document.getElementById('progressBar');
        const progressContainer = document.getElementById('progressContainer');
        const outputImage = document.getElementById('outputImage');
        const outputPlaceholder = document.getElementById('outputPlaceholder');
        const downloadLink = document.getElementById('downloadLink');

        // New elements for queue display
        const queueSizeSpan = document.getElementById('queueSize');
        const processingStatusSpan = document.getElementById('processingStatus');
        const yourPositionSpan = document.getElementById('yourPosition'); // New element

        let currentRequestId = null; // Store the requestId for this client

        function showPreview(file) {
            const reader = new FileReader();
            reader.onload = e => {
                previewImage.src = e.target.result;
                previewImage.style.display = 'block';
                dropText.style.display = 'none';
            };
            reader.readAsDataURL(file);
        }

        imageInput.addEventListener('change', () => {
            if (imageInput.files[0]) showPreview(imageInput.files[0]);
        });

        ['dragenter', 'dragover'].forEach(event =>
            dropArea.addEventListener(event, e => {
                e.preventDefault();
                e.stopPropagation();
                dropArea.classList.add('drag-over');
            })
        );

        ['dragleave', 'drop'].forEach(event =>
            dropArea.addEventListener(event, e => {
                e.preventDefault();
                e.stopPropagation();
                dropArea.classList.remove('drag-over');
            })
        );

        dropArea.addEventListener('click', () => imageInput.click());

        dropArea.addEventListener('drop', e => {
            const file = e.dataTransfer.files[0];
            if (file) {
                imageInput.files = e.dataTransfer.files;
                showPreview(file);
            }
        });

        uploadForm.addEventListener('submit', function (e) {
            e.preventDefault();

            if (!imageInput.files || imageInput.files.length === 0) {
                alert('Please select an image before uploading.');
                return;
            }

            const formData = new FormData();
            formData.append('image', imageInput.files[0]);

            const xhr = new XMLHttpRequest();

            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';

            // Hide previous output and download link when a new upload starts
            outputImage.style.display = 'none';
            outputPlaceholder.style.display = 'block';
            downloadLink.style.display = 'none';

            // Reset currentRequestId and position display
            currentRequestId = null;
            yourPositionSpan.textContent = 'Submitting...';


            xhr.upload.addEventListener('progress', e => {
                if (e.lengthComputable) {
                    const percent = (e.loaded / e.total) * 100;
                    progressBar.style.width = percent + '%';
                }
            });

            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4) {
                    progressContainer.style.display = 'none';

                    if (xhr.status === 202) { // Expect 202 Accepted for initial queue placement
                        const response = JSON.parse(xhr.responseText);
                        currentRequestId = response.requestId; // Store the received requestId
                        queueSizeSpan.textContent = response.queueSize; // Initial queue size
                        yourPositionSpan.textContent = response.yourPosition > 0 ? response.yourPosition : 'Processing'; // Initial position

                        // Start polling after the request is enqueued
                        // If you already have setInterval running, this will just update it
                        // You might want to clear and restart it if you have complex polling logic
                        // For simplicity, let the existing setInterval continue.
                        // It will pick up the `currentRequestId` on its next cycle.
                    } else if (xhr.status === 200) { // This will be the FINAL response with the image
                         const response = JSON.parse(xhr.responseText);
                         outputImage.src = response.outputImage;
                         outputImage.style.display = 'block';
                         outputPlaceholder.style.display = 'none';

                         const filename = response.outputImage.split('/').pop();
                         downloadLink.href = response.outputImage;
                         downloadLink.setAttribute('download', filename);
                         downloadLink.style.display = 'inline-block';

                         // Clear requestId once processing is complete for this client
                         currentRequestId = null;
                         yourPositionSpan.textContent = 'Done!';
                    }
                    else {
                        alert('Processing failed or invalid response from server.');
                        console.error(xhr.responseText);
                        yourPositionSpan.textContent = 'Error';
                        currentRequestId = null; // Clear on error
                    }

                    progressBar.style.width = '0%';
                }
            };

            xhr.open('POST', '/upload', true);
            xhr.send(formData);
        });

        // --- Frontend Queue Polling ---
        async function fetchQueueStatus() {
            try {
                let url = '/queue-status';
                if (currentRequestId) {
                    url += `?requestId=${currentRequestId}`; // Add requestId to the query
                }

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                queueSizeSpan.textContent = data.queueSize;
                processingStatusSpan.textContent = data.isProcessing ? 'Busy' : 'Idle';

                if (currentRequestId) {
                    // If the request ID is still in the queue
                    if (data.yourPosition > 0) {
                        yourPositionSpan.textContent = `${data.yourPosition}`;
                    } else if (data.isProcessing && data.queueSize === 0) {
                        // This case attempts to cover when 'your' request is being processed
                        // and it's the only one, or it was just dequeued.
                        // This is a heuristic and less robust than dedicated tracking.
                        yourPositionSpan.textContent = 'Processing';
                    } else {
                        // If currentRequestId is set, but not in queue and not currently processing
                        // implies it's already finished (or an error occurred).
                        // This can also mean it just finished and the image is being served.
                        // The XHR.status 200 handles the final completion.
                        yourPositionSpan.textContent = 'Done / N/A';
                    }
                } else {
                    yourPositionSpan.textContent = 'N/A'; // No active request
                }

            } catch (error) {
                console.error('Error fetching queue status:', error);
                queueSizeSpan.textContent = 'Error';
                processingStatusSpan.textContent = 'Error';
                yourPositionSpan.textContent = 'Error';
            }
        }

        // Poll the queue status every 2 seconds
        setInterval(fetchQueueStatus, 2000); // Poll every 2 seconds
        fetchQueueStatus(); // Fetch immediately on page load
    </script>
</body>
</html>