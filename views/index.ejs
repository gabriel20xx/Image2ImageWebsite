<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Image Nudifier</title>
    <link rel="stylesheet" href="/style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/socket.io/socket.io.js"></script>
</head>

<body>
    <h1>Image Nudifier</h1>

    <form id="uploadForm" enctype="multipart/form-data">
        <p id="queueStatusDisplay">Queue: <span id="queueSize">0</span>, Status: <span
                id="processingStatus">Idle</span><span class="progressPercentage"></span>, Your
            Position: <span id="yourPosition">N/A</span></p>
        <div class="main-container">
            <div class="upload-section">
                <h2>Upload Image</h2>
                <div id="dropArea" class="drop-area image-box">
                    <p id="dropText" class="placeholder">Drag & drop or click to upload</p>
                    <img id="previewImage" />
                    <input id="inputImage" type="file" name="image" accept="image/*" />
                </div>
                <button class="upload-btn" type="submit">Upload</button>
            </div>
            <div class="output-section">
                <h2>Processed Output</h2>
                <div id="outputArea" class="image-box">
                    <p id="outputPlaceholder" class="placeholder">Your processed image will appear here.<br><span class="progressPercentage"></span></p>
                    <img id="outputImage" src="" alt="Processed Image" style="display:none;" />
                </div>
                <a id="downloadLink" href="#" download style="display:none;">
                    <button class="download-btn" type="button">Download</button>
                </a>
            </div>
        </div>
    </form>

    <div class="settings-section">
        <h2>Settings</h2>
        <p>Future filters and options will go here.</p>
    </div>
    <script>
        // DOM Elements
        const inputImage = document.getElementById('inputImage');
        const previewImage = document.getElementById('previewImage');
        const dropArea = document.getElementById('dropArea');
        const dropText = document.getElementById('dropText');
        const uploadForm = document.getElementById('uploadForm');
        const outputImage = document.getElementById('outputImage');
        const outputPlaceholder = document.getElementById('outputPlaceholder');
        const downloadLink = document.getElementById('downloadLink');

        const queueSizeSpan = document.getElementById('queueSize');
        const processingStatusSpan = document.getElementById('processingStatus');
        const yourPositionSpan = document.getElementById('yourPosition');
        const progressPercentageSpan = document.getElementsByClassName('progressPercentage');

        // State Variables
        let currentRequestId = null;
        let pollingIntervalId = null;

        // --- Socket.IO Setup ---
        const socket = io();

        socket.on('connect', () => {
            console.log('Socket.IO: Connected to server.');
            // Only attempt to rejoin if currentRequestId is set (e.g., after a refresh)
            if (currentRequestId) {
                socket.emit('joinRoom', currentRequestId);
                console.log(`Socket.IO: Rejoining room ${currentRequestId}`);
            }
        });

        socket.on('disconnect', () => {
            console.log('Socket.IO: Disconnected from server.');
        });

        // Listen for processing progress updates from the server
        socket.on('processingProgress', (progress) => {
            console.log('Socket.IO: Received processingProgress:', progress);
            let percentage;

            if (progress.type === "global_steps") {
                percentage = Math.round((progress.value / progress.max) * 100);
            } else {
                percentage = Math.round((progress.value / progress.max) * 100);
            }

            if (isNaN(percentage)) {
                console.warn('Frontend: Invalid percentage received in processingProgress:', progress);
                return;
            }

            progressPercentageSpan.textContent = `: ${percentage}%`;
            processingStatusSpan.textContent = 'Processing';
            outputPlaceholder.textContent = 'Processing your image...'; // Update placeholder text
        });

        // Listen for immediate queue updates (e.g., when your turn comes)
        socket.on('queueUpdate', (data) => {
            console.log('Socket.IO: Received queueUpdate:', data);
            queueSizeSpan.textContent = data.queueSize;

            // This block is for *general* queue updates for the current request,
            // not specifically for completion.
            if (currentRequestId && data.requestId === currentRequestId) {
                if (data.status === 'processing') {
                    yourPositionSpan.textContent = 'Processing';
                    processingStatusSpan.textContent = 'Processing';
                    // progressPercentageSpan is updated by 'processingProgress' event
                    outputPlaceholder.textContent = 'Processing your image...';
                    outputPlaceholder.style.display = 'block';
                    outputImage.style.display = 'none';
                    downloadLink.style.display = 'none';
                } else if (data.status === 'pending') {
                    yourPositionSpan.textContent = `${data.yourPosition}`;
                    processingStatusSpan.textContent = 'Waiting';
                    progressPercentageSpan.textContent = '';
                    outputPlaceholder.textContent = `Waiting in queue: Position ${data.yourPosition}`;
                    outputPlaceholder.style.display = 'block';
                    outputImage.style.display = 'none';
                    downloadLink.style.display = 'none';
                }
            } else if (!currentRequestId && !data.isProcessing && data.queueSize === 0) {
                // This is the global idle state. Ensure it doesn't override a just-shown image.
                // It should only reset the UI if truly idle AND no specific request is active.
                // The `fetchQueueStatus` function handles the final cleanup and setting to idle.
                processingStatusSpan.textContent = 'Idle';
                yourPositionSpan.textContent = 'N/A';
                progressPercentageSpan.textContent = '';
                outputPlaceholder.textContent = 'Your processed image will appear here.';
                outputPlaceholder.style.display = 'block';
                outputImage.style.display = 'none'; // Ensure hidden if completely idle
                downloadLink.style.display = 'none'; // Ensure hidden if completely idle
            }
        });


        // Handle processing completion via Socket.IO
        socket.on('processingComplete', (data) => {
            console.log('Socket.IO: Received processingComplete event with data:', data);
            // Check if the completed request is the one we are currently tracking
            // AND the requestId in the data matches our tracked one, AND it has an outputImage
            if (currentRequestId && data.requestId === currentRequestId && data.outputImage) {
                console.log(`Frontend: Condition met for processingComplete. Request ID: ${currentRequestId}.`);
                yourPositionSpan.textContent = 'Done!';
                processingStatusSpan.textContent = 'Complete';
                progressPercentageSpan.textContent = '';

                // This is the CRITICAL call that makes the image and download link visible
                displayResult(data.outputImage);

                // *** IMPORTANT FIX: DO NOT CLEAR currentRequestId HERE! ***
                // Let the `fetchQueueStatus` polling mechanism (specifically the 'completed' case)
                // be the definitive place to clear currentRequestId and stop polling.
                // This prevents `fetchQueueStatus` from immediately overriding the UI state.

                // If you *must* stop polling immediately here, you'd need a more complex state
                // management to ensure `fetchQueueStatus` doesn't re-hide the image.
                // For now, removing `currentRequestId = null;` is the key.

                if (pollingIntervalId) {
                    clearInterval(pollingIntervalId);
                    pollingIntervalId = null; // Stop polling now that we received completion via Socket.IO
                    console.log('Frontend: Polling stopped by processingComplete event.');
                }
            } else {
                console.warn('Frontend: Processing complete event received, but condition not met or not for current request.',
                    'currentRequestId:', currentRequestId,
                    'data.requestId:', data.requestId,
                    'data.outputImage exists:', !!data.outputImage
                );
            }
            fetchQueueStatus(); // Still call this to ensure global queue status updates
        });

        // Listen for processing failure
        socket.on('processingFailed', (data) => {
            console.error('Socket.IO: Processing failed:', data);
            if (currentRequestId && data.requestId === currentRequestId) {
                console.error(`Frontend: Processing failed for tracked request ID ${currentRequestId}.`);
                yourPositionSpan.textContent = 'Error!';
                processingStatusSpan.textContent = 'Failed';
                progressPercentageSpan.textContent = '';
                displayError(data.errorMessage || 'Unknown processing error.');
                currentRequestId = null; // Clear current request ID on failure
                if (pollingIntervalId) {
                    clearInterval(pollingIntervalId);
                    pollingIntervalId = null;
                    console.log('Frontend: Polling stopped due to processing failure.');
                }
            } else {
                console.warn('Frontend: Processing failed for an untracked request or without request ID:', data);
            }
            fetchQueueStatus(); // Update overall queue status
        });

        // --- UI Helper Functions ---
        function resetUIForNewUpload() {
            console.log('Frontend: Resetting UI for a new upload.');
            outputImage.style.display = 'none';
            outputImage.src = ''; // Clear previous image source
            outputPlaceholder.style.display = 'block';
            outputPlaceholder.style.color = '#fff'; // Reset color in case of previous error
            outputPlaceholder.textContent = 'Uploading...';
            downloadLink.style.display = 'none';
            downloadLink.href = '#';
            currentRequestId = null; // Clear old request ID
            yourPositionSpan.textContent = 'Submitting...';
            processingStatusSpan.textContent = 'Uploading...';
            progressPercentageSpan.textContent = '';
            queueSizeSpan.textContent = '0';

            // Ensure polling is stopped for the previous request if a new one starts
            if (pollingIntervalId) {
                clearInterval(pollingIntervalId);
                pollingIntervalId = null;
                console.log('Frontend: Polling cleared due to new upload.');
            }
        }

        function displayResult(imageUrl) {
            console.log('Frontend: displayResult called with imageUrl:', imageUrl);

            if (!imageUrl) {
                console.error('Frontend: displayResult received an empty or null imageUrl. Cannot display image.');
                displayError("No image URL provided for display.");
                return;
            }

            outputImage.src = imageUrl;
            console.log('Frontend: outputImage.src set to:', outputImage.src);

            // Add detailed onload/onerror handlers for the image element
            // These handlers ensure the display property is set AFTER the image is confirmed loaded.
            outputImage.onload = () => {
                console.log('Frontend: Image loaded successfully from:', outputImage.src);
                outputImage.style.display = 'block'; // Make the image visible
                outputPlaceholder.style.display = 'none'; // Hide the placeholder
                console.log('Frontend: Output image displayed. Placeholder hidden.');
            };

            outputImage.onerror = () => {
                console.error('Frontend: Failed to load image from:', outputImage.src);
                displayError("Failed to load processed image. Check console for network errors.");
                outputImage.style.display = 'none'; // Ensure image is hidden on error
                outputPlaceholder.style.display = 'block'; // Show placeholder with error message
            };

            const filename = imageUrl.split('/').pop();
            downloadLink.href = imageUrl;
            downloadLink.setAttribute('download', filename);
            downloadLink.style.display = 'inline-block'; // Make the download link visible
            console.log('Frontend: Download link set and displayed for filename:', filename);
        }

        function displayError(errorMessage) {
            console.error('Frontend: Displaying error:', errorMessage);
            outputPlaceholder.textContent = `Error: ${errorMessage}`;
            outputPlaceholder.style.color = 'red';
            outputPlaceholder.style.display = 'block';
            outputImage.style.display = 'none';
            downloadLink.style.display = 'none';
        }

        // --- Image Preview and Drag/Drop ---
        function showPreview(file) {
            console.log('Frontend: Showing preview for selected file:', file.name);
            const reader = new FileReader();
            reader.onload = e => {
                previewImage.src = e.target.result;
                previewImage.style.display = 'block';
                dropText.style.display = 'none';
                console.log('Frontend: Preview image updated.');
            };
            reader.readAsDataURL(file);
        }

        inputImage.addEventListener('change', () => {
            if (inputImage.files[0]) showPreview(inputImage.files[0]);
        });

        ['dragenter', 'dragover'].forEach(event =>
            dropArea.addEventListener(event, e => {
                e.preventDefault();
                e.stopPropagation();
                dropArea.classList.add('drag-over');
            })
        );

        ['dragleave', 'drop'].forEach(event =>
            dropArea.addEventListener(event, e => {
                e.preventDefault();
                e.stopPropagation();
                dropArea.classList.remove('drag-over');
            })
        );

        dropArea.addEventListener('click', () => inputImage.click());

        dropArea.addEventListener('drop', e => {
            const file = e.dataTransfer.files[0];
            if (file) {
                inputImage.files = e.dataTransfer.files;
                showPreview(file);
            }
        });

        // --- Upload Form Submission ---
        uploadForm.addEventListener('submit', function (e) {
            e.preventDefault();
            console.log('Frontend: Upload form submitted.');

            if (!inputImage.files || inputImage.files.length === 0) {
                alert('Please select an image before uploading.');
                console.warn('Frontend: No image selected for upload.');
                return;
            }

            resetUIForNewUpload(); // Clear UI for new upload

            const formData = new FormData();
            formData.append('image', inputImage.files[0]);
            console.log('Frontend: FormData created with image file.');

            const xhr = new XMLHttpRequest();

            xhr.upload.addEventListener('progress', e => {
                if (e.lengthComputable) {
                    const percent = (e.loaded / e.total) * 100;
                    processingStatusSpan.textContent = `Uploading: ${Math.round(percent)}%`;
                    console.log(`Frontend: Upload progress: ${Math.round(percent)}%`);
                }
            });

            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4) {
                    if (xhr.status === 202) {
                        const response = JSON.parse(xhr.responseText);
                        currentRequestId = response.requestId; // Set currentRequestId here
                        console.log(`Frontend: Upload successful. Request ID: ${currentRequestId}. Response:`, response);

                        socket.emit('joinRoom', currentRequestId);
                        console.log(`Frontend: Sent 'joinRoom' for Request ID: ${currentRequestId}`);

                        queueSizeSpan.textContent = response.queueSize;
                        yourPositionSpan.textContent = response.yourPosition > 0 ? response.yourPosition : 'Processing';
                        processingStatusSpan.textContent = 'Waiting';
                        progressPercentageSpan.textContent = '';
                        outputPlaceholder.textContent = `Image uploaded. Waiting for processing.`;
                        console.log('Frontend: UI updated to waiting state.');

                        // Start polling if not already started
                        if (!pollingIntervalId) {
                            pollingIntervalId = setInterval(fetchQueueStatus, 2000);
                            console.log('Frontend: Started queue status polling.');
                        }
                        fetchQueueStatus(); // Immediate fetch to update status
                    } else {
                        const errorResponse = xhr.responseText || 'Unknown error';
                        alert('Upload failed: ' + errorResponse);
                        console.error('Frontend: Upload failed with status', xhr.status, 'Error:', errorResponse);
                        displayError('Upload failed: ' + errorResponse);
                        currentRequestId = null; // Clear ID on upload failure
                        if (pollingIntervalId) {
                            clearInterval(pollingIntervalId);
                            pollingIntervalId = null;
                            console.log('Frontend: Polling stopped due to upload failure.');
                        }
                        yourPositionSpan.textContent = 'Error';
                        processingStatusSpan.textContent = 'Failed';
                        progressPercentageSpan.textContent = '';
                    }
                }
            };

            xhr.open('POST', '/upload', true);
            xhr.send(formData);
        });

        // --- Frontend Queue Polling ---
        async function fetchQueueStatus() {
            try {
                let url = '/queue-status';
                if (currentRequestId) {
                    url += `?requestId=${currentRequestId}`;
                }
                console.log('Frontend: Fetching queue status from:', url);

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('Frontend: Polling queue status received:', data);

                queueSizeSpan.textContent = data.queueSize;

                // If a current request is being tracked
                if (currentRequestId) {
                    // Update specific status based on what server reports for *this* requestId
                    switch (data.status) {
                        case 'pending':
                            yourPositionSpan.textContent = `${data.yourPosition}`;
                            processingStatusSpan.textContent = 'Waiting';
                            progressPercentageSpan.textContent = '';
                            outputPlaceholder.textContent = `Waiting in queue: Position ${data.yourPosition}`;
                            outputPlaceholder.style.display = 'block';
                            outputImage.style.display = 'none';
                            downloadLink.style.display = 'none';
                            console.log('Frontend: Polling updated: Status pending.');
                            break;
                        case 'processing':
                            yourPositionSpan.textContent = 'Processing';
                            processingStatusSpan.textContent = 'Processing';
                            outputPlaceholder.textContent = 'Processing your image...';
                            outputPlaceholder.style.display = 'block';
                            outputImage.style.display = 'none';
                            downloadLink.style.display = 'none';
                            console.log('Frontend: Polling updated: Status processing.');
                            // Progress percentage is mainly from Socket.IO's 'processingProgress' event
                            break;
                        case 'completed':
                            yourPositionSpan.textContent = 'Done!';
                            processingStatusSpan.textContent = 'Complete';
                            progressPercentageSpan.textContent = '';
                            // This part handles display if Socket.IO message was missed
                            if (data.result && data.result.outputImage) {
                                console.log('Frontend: Polling detected completed status with image, calling displayResult.');
                                displayResult(data.result.outputImage);
                            } else {
                                console.warn('Frontend: Polling detected completed status but no outputImage in data.result. This should not happen if backend is correct.');
                            }
                            currentRequestId = null; // Clear ID after completion is confirmed
                            if (pollingIntervalId) {
                                clearInterval(pollingIntervalId);
                                pollingIntervalId = null;
                                console.log('Frontend: Polling stopped after detecting completed status.');
                            }
                            break;
                        case 'failed':
                            yourPositionSpan.textContent = 'Error!';
                            processingStatusSpan.textContent = 'Failed';
                            progressPercentageSpan.textContent = '';
                            displayError(data.result.errorMessage || 'Unknown processing error from polling.');
                            currentRequestId = null; // Clear ID on failure
                            if (pollingIntervalId) {
                                clearInterval(pollingIntervalId);
                                pollingIntervalId = null;
                                console.log('Frontend: Polling stopped after detecting failed status.');
                            }
                            break;
                        default:
                            yourPositionSpan.textContent = 'N/A';
                            progressPercentageSpan.textContent = '';
                            console.log('Frontend: Polling updated: Unknown status encountered for current request.');
                            break;
                    }
                }
                // Handle global idle state if no specific request is being tracked
                else if (!data.isProcessing && data.queueSize === 0) {
                    processingStatusSpan.textContent = 'Idle';
                    yourPositionSpan.textContent = 'N/A';
                    progressPercentageSpan.textContent = '';
                    outputPlaceholder.textContent = 'Your processed image will appear here.';
                    outputPlaceholder.style.display = 'block';
                    outputImage.style.display = 'none'; // Only hide if truly idle
                    downloadLink.style.display = 'none'; // Only hide if truly idle
                    if (pollingIntervalId) {
                        clearInterval(pollingIntervalId);
                        pollingIntervalId = null;
                        console.log('Frontend: Polling stopped as queue is idle and no current request.');
                    }
                } else {
                    // This covers cases where no specific request is tracked, but queue is not empty or processing
                    console.log('Frontend: Polling: Not tracking a specific request, and queue is not idle. Waiting for upload.');
                }
            } catch (error) {
                console.error('Frontend: Error fetching queue status:', error);
                // Only show error for tracked request or general system error
                if (currentRequestId || processingStatusSpan.textContent !== 'Idle') {
                    queueSizeSpan.textContent = 'Error';
                    processingStatusSpan.textContent = 'Error';
                    yourPositionSpan.textContent = 'Error';
                    progressPercentageSpan.textContent = '';
                    displayError('Failed to get status. Please check connection.');
                    if (pollingIntervalId) {
                        clearInterval(pollingIntervalId);
                        pollingIntervalId = null;
                        console.log('Frontend: Polling stopped due to error.');
                    }
                }
            }
        }

        // Initial fetch and start polling when the page loads
        // This ensures UI is up-to-date even on refresh.
        fetchQueueStatus();
        if (!pollingIntervalId) { // Prevent multiple intervals if already started
            pollingIntervalId = setInterval(fetchQueueStatus, 2000);
            console.log('Frontend: Initial polling started.');
        }
    </script>
</body>

</html>