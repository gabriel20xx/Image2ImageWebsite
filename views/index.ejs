<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Image Nudifier</title>
    <link rel="stylesheet" href="/style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <h1>Image Nudifier</h1>

    <form id="uploadForm" enctype="multipart/form-data">
        <p id="queueStatus">Queue: <span id="queueSize">0</span>, Status: <span id="processingStatus">Idle</span>, Your
            Position: <span id="yourPosition">N/A</span></p>
        <div id="progressContainer" style="display:none;">
            <div id="progressBar" data-percentage="0%"></div>
        </div>
        <div class="main-container">
            <div class="upload-section">
                <h2>Upload Image</h2>
                <div id="dropArea" class="drop-area image-box">
                    <p id="dropText" class="placeholder">Drag & drop or click to upload</p>
                    <img id="previewImage" />
                    <input id="inputImage" type="file" name="image" accept="image/*" />
                </div>
                <button class="upload-btn" type="submit">Upload</button>
            </div>
            <div class="output-section">
                <h2>Processed Output</h2>
                <div id="outputArea" class="image-box">
                    <p id="outputPlaceholder" class="placeholder">Your processed image will appear here.</p>
                    <img id="outputImage" src="" alt="Processed Image" style="display:none;" />
                </div>
                <a id="downloadLink" href="#" download style="display:none;">
                    <button class="download-btn" type="button">Download</button>
                </a>
            </div>
        </div>
    </form>

    <div class="settings-section">
        <h2>Settings</h2>
        <p>Future filters and options will go here.</p>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const inputImage = document.getElementById('inputImage');
        const previewImage = document.getElementById('previewImage');
        const dropArea = document.getElementById('dropArea');
        const dropText = document.getElementById('dropText');
        const uploadForm = document.getElementById('uploadForm');
        const progressBar = document.getElementById('progressBar');
        const progressContainer = document.getElementById('progressContainer');
        const outputImage = document.getElementById('outputImage');
        const outputPlaceholder = document.getElementById('outputPlaceholder');
        const downloadLink = document.getElementById('downloadLink');

        // New elements for queue display
        const queueSizeSpan = document.getElementById('queueSize');
        const processingStatusSpan = document.getElementById('processingStatus');
        const yourPositionSpan = document.getElementById('yourPosition');

        let currentRequestId = null; // Store the requestId for this client's active job
        let pollingIntervalId = null; // To store the interval ID for polling

        // --- Socket.IO Setup ---
        const socket = io(); // Connects to the server where the script is served from

        socket.on('connect', () => {
            console.log('Socket.IO: Connected to server.');
            // When connecting/reconnecting, if we had an active request, try to rejoin its room.
            // This helps with page refreshes if the server still holds the state for this requestId.
            if (currentRequestId) {
                socket.emit('joinRoom', currentRequestId);
                console.log(`Socket.IO: Rejoining room ${currentRequestId}`);
            }
        });

        socket.on('disconnect', () => {
            console.log('Socket.IO: Disconnected from server.');
            // No need to clear polling here; polling handles its own lifecycle based on request completion.
        });

        // Listen for processing progress updates from the server
        socket.on('processingProgress', (progress) => {
            // console.log('Socket.IO: Received processingProgress:', progress); // Debugging line
            if (currentRequestId && processingStatusSpan.textContent === 'Processing') {
                const percentage = Math.round((progress.value / progress.max) * 100);
                if (isNaN(percentage)) { // Handle division by zero or invalid numbers
                    console.warn('Invalid percentage received:', progress);
                    return;
                }
                progressBar.style.width = `${percentage}%`;
                progressBar.setAttribute('data-percentage', `${percentage}%`); // Update data attribute for CSS ::after
                outputPlaceholder.textContent = `Processing image: ${percentage}% complete...`;
                progressContainer.style.display = 'block'; // Ensure progress bar is visible
            }
        });

        // Listen for immediate queue updates (e.g., when your turn comes)
        socket.on('queueUpdate', (data) => {
            console.log('Socket.IO: Received queueUpdate:', data);
            // Always update general queue stats
            queueSizeSpan.textContent = data.queueSize;
            processingStatusSpan.textContent = data.isProcessing ? 'Busy' : 'Idle';

            if (data.requestId === currentRequestId) { // Ensure update is for our request
                if (data.status === 'processing') {
                    yourPositionSpan.textContent = 'Processing';
                    processingStatusSpan.textContent = 'Processing';
                    outputPlaceholder.textContent = 'Processing your image...';
                    progressContainer.style.display = 'block'; // Show progress bar
                    progressBar.style.width = '0%'; // Reset for new processing
                    progressBar.setAttribute('data-percentage', '0%');
                    // Progress percentage will be updated by 'processingProgress' event
                } else if (data.status === 'pending') {
                    yourPositionSpan.textContent = `${data.yourPosition}`;
                    processingStatusSpan.textContent = 'Waiting';
                    outputPlaceholder.textContent = `Waiting in queue: Position ${data.yourPosition}`;
                    progressContainer.style.display = 'none'; // Hide progress bar if pending
                }
            } else if (!currentRequestId && !data.isProcessing && data.queueSize === 0) {
                // General update for idle state if no current request
                processingStatusSpan.textContent = 'Idle';
                yourPositionSpan.textContent = 'N/A';
                progressContainer.style.display = 'none'; // Hide if genuinely idle
                progressBar.style.width = '0%';
                progressBar.setAttribute('data-percentage', '0%');
            }
        });

        // Listen for processing completion
        socket.on('processingComplete', (data) => {
            // Only act if this completion matches our current request
            if (data.requestId === currentRequestId) {
                console.log('Socket.IO: Processing complete:', data);
                yourPositionSpan.textContent = 'Done!';
                processingStatusSpan.textContent = 'Complete';
                if (data.outputImage) {
                    displayResult(data.outputImage);
                }
                currentRequestId = null; // Clear request ID as it's done
                if (pollingIntervalId) {
                    clearInterval(pollingIntervalId); // Stop polling once done
                    pollingIntervalId = null;
                }
                progressContainer.style.display = 'none'; // Hide progress bar
                progressBar.style.width = '0%';
                progressBar.setAttribute('data-percentage', '0%');
            }
            // Always fetch general queue status after a job completes (ours or someone else's)
            fetchQueueStatus();
        });

        // Listen for processing failure
        socket.on('processingFailed', (data) => {
            // Only act if this failure matches our current request
            if (data.requestId === currentRequestId) {
                console.error('Socket.IO: Processing failed:', data);
                yourPositionSpan.textContent = 'Error!';
                processingStatusSpan.textContent = 'Failed';
                displayError(data.errorMessage || 'Unknown processing error.');
                currentRequestId = null; // Clear request ID as it's done
                if (pollingIntervalId) {
                    clearInterval(pollingIntervalId); // Stop polling
                    pollingIntervalId = null;
                }
                progressContainer.style.display = 'none'; // Hide progress bar
                progressBar.style.width = '0%';
                progressBar.setAttribute('data-percentage', '0%');
            }
            // Always fetch general queue status after a job fails (ours or someone else's)
            fetchQueueStatus();
        });


        // --- UI Helper Functions ---
        function resetUIForNewUpload() {
            outputImage.style.display = 'none';
            outputImage.src = ''; // Clear previous image
            outputPlaceholder.style.display = 'block';
            outputPlaceholder.style.color = '#333'; // Reset color if it was red from an error
            outputPlaceholder.textContent = 'Your processed image will appear here.'; // Reset text
            downloadLink.style.display = 'none';
            downloadLink.href = '#';
            currentRequestId = null; // Ensure this is clear for a new upload
            yourPositionSpan.textContent = 'Submitting...';
            processingStatusSpan.textContent = 'Uploading...'; // Indicate upload is happening
            queueSizeSpan.textContent = '0'; // Will be updated by server response

            progressContainer.style.display = 'block'; // Show progress bar initially for upload
            progressBar.style.width = '0%';
            progressBar.setAttribute('data-percentage', '0%'); // Reset text

            if (pollingIntervalId) { // Clear any ongoing polling interval
                clearInterval(pollingIntervalId);
                pollingIntervalId = null;
            }
        }

        function displayProcessingMessage(message) {
            outputPlaceholder.textContent = message;
            outputPlaceholder.style.display = 'block';
            outputImage.style.display = 'none';
            downloadLink.style.display = 'none';
        }

        function displayResult(imageUrl) {
            outputImage.src = imageUrl;
            outputImage.style.display = 'block';
            outputPlaceholder.style.display = 'none';

            const filename = imageUrl.split('/').pop();
            downloadLink.href = imageUrl;
            downloadLink.setAttribute('download', filename);
            downloadLink.style.display = 'inline-block';
        }

        function displayError(errorMessage) {
            outputPlaceholder.textContent = `Error: ${errorMessage}`;
            outputPlaceholder.style.color = 'red';
            outputPlaceholder.style.display = 'block';
            outputImage.style.display = 'none';
            downloadLink.style.display = 'none';
        }


        // --- Image Preview and Drag/Drop ---
        function showPreview(file) {
            const reader = new FileReader();
            reader.onload = e => {
                previewImage.src = e.target.result;
                previewImage.style.display = 'block';
                dropText.style.display = 'none';
            };
            reader.readAsDataURL(file);
        }

        inputImage.addEventListener('change', () => {
            if (inputImage.files[0]) showPreview(inputImage.files[0]);
        });

        ['dragenter', 'dragover'].forEach(event =>
            dropArea.addEventListener(event, e => {
                e.preventDefault();
                e.stopPropagation();
                dropArea.classList.add('drag-over');
            })
        );

        ['dragleave', 'drop'].forEach(event =>
            dropArea.addEventListener(event, e => {
                e.preventDefault();
                e.stopPropagation();
                dropArea.classList.remove('drag-over');
            })
        );

        dropArea.addEventListener('click', () => inputImage.click());

        dropArea.addEventListener('drop', e => {
            const file = e.dataTransfer.files[0];
            if (file) {
                inputImage.files = e.dataTransfer.files;
                showPreview(file);
            }
        });

        // --- Upload Form Submission ---
        uploadForm.addEventListener('submit', function (e) {
            e.preventDefault();

            if (!inputImage.files || inputImage.files.length === 0) {
                alert('Please select an image before uploading.');
                return;
            }

            resetUIForNewUpload(); // Reset UI state for a new upload

            const formData = new FormData();
            formData.append('image', inputImage.files[0]);

            const xhr = new XMLHttpRequest();

            // Set up upload progress for the file upload itself (not ComfyUI processing)
            xhr.upload.addEventListener('progress', e => {
                if (e.lengthComputable) {
                    const percent = (e.loaded / e.total) * 100;
                    progressBar.style.width = percent + '%';
                    progressBar.setAttribute('data-percentage', `${Math.round(percent)}%`); // Update data attribute
                    outputPlaceholder.textContent = `Uploading: ${Math.round(percent)}%`;
                    processingStatusSpan.textContent = 'Uploading';
                }
            });

            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4) {
                    if (xhr.status === 202) { // Server accepted and enqueued
                        const response = JSON.parse(xhr.responseText);
                        currentRequestId = response.requestId; // Store the received requestId

                        // Join the Socket.IO room for this specific requestId
                        socket.emit('joinRoom', currentRequestId);
                        console.log(`Frontend: Sent 'joinRoom' for Request ID: ${currentRequestId}`);

                        // Update initial queue status immediately from response
                        queueSizeSpan.textContent = response.queueSize;
                        yourPositionSpan.textContent = response.yourPosition > 0 ? response.yourPosition : 'Processing';
                        processingStatusSpan.textContent = 'Waiting for server...';
                        outputPlaceholder.textContent = `Image uploaded. Waiting for processing.`;


                        // Reset progress bar visual for processing stage (will be updated by Socket.IO)
                        progressBar.style.width = '0%';
                        progressBar.setAttribute('data-percentage', '0%');
                        // progressContainer.style.display = 'block'; // Already set in resetUIForNewUpload

                        // Start polling for overall queue status. The Socket.IO
                        // events will provide the real-time progress for *our* job.
                        if (!pollingIntervalId) {
                            pollingIntervalId = setInterval(fetchQueueStatus, 2000);
                        }
                        // Immediately fetch status after enqueuing for quick update
                        fetchQueueStatus();

                    } else { // Handle upload errors
                        alert('Upload failed: ' + xhr.responseText);
                        console.error('Upload error:', xhr.responseText);
                        displayError('Upload failed: ' + xhr.responseText);
                        currentRequestId = null; // Clear request ID on upload failure
                        if (pollingIntervalId) {
                            clearInterval(pollingIntervalId); // Stop polling if upload fails
                            pollingIntervalId = null;
                        }
                        yourPositionSpan.textContent = 'Error';
                        processingStatusSpan.textContent = 'Failed';
                        progressContainer.style.display = 'none'; // Hide progress bar on failure
                    }
                }
            };

            xhr.open('POST', '/upload', true);
            xhr.send(formData);
        });

        // --- Frontend Queue Polling ---
        async function fetchQueueStatus() {
            try {
                let url = '/queue-status';
                // Only request status for our specific requestId if we have one active
                if (currentRequestId) {
                    url += `?requestId=${currentRequestId}`;
                }

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                // console.log('Polling queue status:', data); // Debugging line

                // Update general queue stats (always show global queue size)
                queueSizeSpan.textContent = data.queueSize;
                processingStatusSpan.textContent = data.isProcessing ? 'Busy' : 'Idle';

                // Update 'Your Position' and status based on *our* request's status
                if (currentRequestId) { // If we have an active request
                    if (data.requestId === currentRequestId || data.yourPosition !== -1 || data.status === 'processing' || data.status === 'completed' || data.status === 'failed') {
                        switch (data.status) {
                            case 'pending':
                                yourPositionSpan.textContent = `${data.yourPosition}`;
                                outputPlaceholder.textContent = `Waiting in queue: Position ${data.yourPosition}`;
                                progressContainer.style.display = 'none'; // Hide progress bar for pending
                                break;
                            case 'processing':
                                yourPositionSpan.textContent = 'Processing';
                                outputPlaceholder.textContent = 'Processing your image...';
                                progressContainer.style.display = 'block'; // Show progress bar
                                // Progress bar width will be updated by Socket.IO 'processingProgress' event
                                break;
                            case 'completed':
                                yourPositionSpan.textContent = 'Done!';
                                displayResult(data.result.outputImage);
                                currentRequestId = null; // Clear the request ID as it's done
                                if (pollingIntervalId) {
                                    clearInterval(pollingIntervalId); // Stop polling
                                    pollingIntervalId = null;
                                }
                                progressContainer.style.display = 'none'; // Hide progress bar
                                progressBar.style.width = '0%';
                                progressBar.setAttribute('data-percentage', '0%');
                                break;
                            case 'failed':
                                yourPositionSpan.textContent = 'Error!';
                                displayError(data.result.errorMessage || 'Unknown processing error.');
                                currentRequestId = null; // Clear the request ID as it's done
                                if (pollingIntervalId) {
                                    clearInterval(pollingIntervalId); // Stop polling
                                    pollingIntervalId = null;
                                }
                                progressContainer.style.display = 'none'; // Hide progress bar
                                progressBar.style.width = '0%';
                                progressBar.setAttribute('data-percentage', '0%');
                                break;
                            default:
                                yourPositionSpan.textContent = 'N/A'; // Fallback
                                break;
                        }
                    }
                } else { // No currentRequestId, update based on general server state
                    yourPositionSpan.textContent = 'N/A';
                    if (!data.isProcessing && data.queueSize === 0) {
                        processingStatusSpan.textContent = 'Idle';
                        progressContainer.style.display = 'none'; // Hide if idle
                        progressBar.style.width = '0%';
                        progressBar.setAttribute('data-percentage', '0%');
                        if (pollingIntervalId) { // Only stop if genuinely idle and no pending request
                            clearInterval(pollingIntervalId);
                            pollingIntervalId = null;
                        }
                    }
                }
            } catch (error) {
                console.error('Error fetching queue status:', error);
                // Only set error status if we have a currentRequestId, otherwise general idle
                if (currentRequestId) {
                    queueSizeSpan.textContent = 'Error';
                    processingStatusSpan.textContent = 'Error';
                    yourPositionSpan.textContent = 'Error';
                    displayError('Failed to get status. Please check connection.');
                    if (pollingIntervalId) {
                        clearInterval(pollingIntervalId);
                        pollingIntervalId = null;
                    }
                }
            }
        }

        // Initial fetch on page load and start polling
        // The polling loop ensures status updates, especially for general queue size
        // and if a job moves to 'processing' before the Socket.IO 'processingStarted' fires.
        fetchQueueStatus(); // Get initial state
        if (!pollingIntervalId) { // Ensure polling starts if not already active
            pollingIntervalId = setInterval(fetchQueueStatus, 2000);
        }

    </script>
</body>

</html>